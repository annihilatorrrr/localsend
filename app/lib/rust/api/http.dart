// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:localsend_app/rust/api/model.dart';
import 'package:localsend_app/rust/api/stream.dart';
import 'package:localsend_app/rust/frb_generated.dart';

Future<RsHttpClient> createClient({
  required String privateKey,
  required String cert,
  required LsHttpClientVersion version,
}) => RustLib.instance.api.crateApiHttpCreateClient(
  privateKey: privateKey,
  cert: cert,
  version: version,
);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientError>>
abstract class ClientError implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RsHttpClient>>
abstract class RsHttpClient implements RustOpaqueInterface {
  Future<void> cancel({
    required ProtocolType protocol,
    required String ip,
    required int port,
    required String sessionId,
  });

  Future<PrepareUploadResult> prepareUpload({
    required ProtocolType protocol,
    required String ip,
    required int port,
    required PrepareUploadRequestDto payload,
    String? publicKey,
    String? pin,
  });

  Future<ResultWithPublicKeyRegisterResponseDto> register({
    required ProtocolType protocol,
    required String ip,
    required int port,
    required RegisterDto payload,
  });

  Future<void> upload({
    required ProtocolType protocol,
    required String ip,
    required int port,
    String? publicKey,
    required String sessionId,
    required String fileId,
    required String token,
    required Dart2RustStreamReceiver binary,
  });
}

enum LsHttpClientVersion {
  v2,
  v3,
}

class PrepareUploadResult {
  final int statusCode;
  final PrepareUploadResponseDto response;

  const PrepareUploadResult({
    required this.statusCode,
    required this.response,
  });

  @override
  int get hashCode => statusCode.hashCode ^ response.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PrepareUploadResult && runtimeType == other.runtimeType && statusCode == other.statusCode && response == other.response;
}

class ResultWithPublicKeyRegisterResponseDto {
  final String? publicKey;
  final RegisterResponseDto body;

  const ResultWithPublicKeyRegisterResponseDto({
    this.publicKey,
    required this.body,
  });

  @override
  int get hashCode => publicKey.hashCode ^ body.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ResultWithPublicKeyRegisterResponseDto && runtimeType == other.runtimeType && publicKey == other.publicKey && body == other.body;
}
